(* python-bsdl-parser
 *
 * Copyright (c) 2016, Forest Crossman <cyrozap@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)

(* IEEE Std 1149.1-2013, Annex B *)

@@ignorecase :: True
@@eol_comments :: /--.*?$/

(* B.8.1 *)
bsdl_description = "entity" component_name "is"
    generic_parameter
    logical_port_description
    standard_use_statement
    {use_statement}
    component_conformance_statement
    device_package_pin_mappings
    [grouped_port_identification]
    scan_port_identification
    [compliance_enable_description]
    instruction_register_description
    [optional_register_description]
    [register_access_description]
    boundary_scan_register_description
    [runbist_description]
    [intest_description]
    [system_clock_description]
    {register_mnemonics_description}
    {register_fields_description}
    {register_assembly_description}
    {register_constraints_description}
    {register_association_description}
    {power_port_association_description}
    {bsdl_extensions}
    [design_warning]
    "end" component_name semicolon ;

component_name = vhdl_identifier ;

(* B.8.2 *)
generic_parameter = generic_default | generic_no_default ;
generic_default = "generic" left_paren "PHYSICAL_PIN_MAP" colon
    "string" right_paren semicolon ;
generic_no_default = "generic" left_paren "PHYSICAL_PIN_MAP" colon
    "string" colon_equal default_device_package_type right_paren semicolon ;
default_device_package_type = quote pin_mapping_name quote ;

(* B.8.3 *)
logical_port_description = "port" left_paren pin_spec
    { semicolon pin_spec } right_paren semicolon ;
pin_spec = identifier_list colon pin_type port_dimension ;
identifier_list = port_name { comma port_name} ;
pin_type = "in" | "out" | "buffer" | "inout" | "LINKAGE_INOUT" |
    "LINKAGE_BUFFER" | "LINKAGE_IN" | "LINKAGE_OUT" | "LINKAGE_MECHANICAL" |
    "POWER_0" | "POWER_POS" | "POWER_NEG" | "VREF_IN" | "VREF_OUT" ;
port_dimension = "bit" | bit_vector_spec ;
bit_vector_spec  = "bit_vector" left_paren range right_paren ;
range = up_range | down_range ;
up_range = integer1 "to" integer2 ;
down_range = integer2 "downto" integer1 ;
integer1 = integer ;
integer2 = integer ;

(* B.8.4 *)
standard_use_statement = "use" standard_package_name period "all" semicolon ;
standard_package_name = "STD_1149_1_1990" | "STD_1149_1_1994" |
    "STD_1149_1_2001" | "STD_1149_1_2013" ;

(* B.8.5 *)
use_statement = "use" user_package_name period "all" semicolon ;
user_package_name = vhdl_identifier ;

(* B.8.6 *)
component_conformance_statement = "attribute" "COMPONENT_CONFORMANCE" "of"
    component_name colon "entity" "is" conformance_string semicolon ;
conformance_string = quote conformance_identification quote ;
conformance_identification = "STD_1149_1_1990" | "STD_1149_1_1993" |
    "STD_1149_1_2001" | "STD_1149_1_2013" ;

(* B.8.7 *)
device_package_pin_mappings = pin_map_statement pin_mappings ;
pin_map_statement = "attribute" "PIN_MAP" "of" component_name colon "entity" "is"
    "PHYSICAL_PIN_MAP" semicolon ;
pin_mappings = pin_mapping { pin_mapping } ;
pin_mapping = "constant" pin_mapping_name colon "PIN_MAP_STRING" ":="
    map_string semicolon ;
pin_mapping_name = vhdl_identifier ;
map_string = quote port_map { comma port_map } quote ;
port_map = port_name colon pin_or_list ;
pin_or_list = pin_desc | pin_list ;
pin_list = left_paren pin_desc { comma pin_desc} right_paren ;
pin_desc = pin_ID | "OPEN" | "TIE0" | "TIE1" ;
pin_ID = vhdl_identifier | integer ;

(* B.8.8 *)
grouped_port_identification = "attribute" "PORT_GROUPING" "of"
    component_name colon "entity" "is" group_table_string semicolon ;
group_table_string = quote group_table quote ;
group_table = twin_group_entry { comma twin_group_entry } ;
twin_group_entry = twin_group_type left_paren twin_group_list right_paren ;
twin_group_type = "DIFFERENTIAL_VOLTAGE" | "DIFFERENTIAL_CURRENT" ;
twin_group_list = twin_group { comma twin_group } ;
twin_group = left_paren representative_port comma associated_port right_paren ;
representative_port = port_ID ;
associated_port = port_ID ;

(* B.8.9 *)
scan_port_identification = scan_port_stmt { scan_port_stmt } ;
scan_port_stmt = TCK_stmt | TDI_stmt | TMS_stmt | TDO_stmt | TRST_stmt ;
TCK_stmt = "attribute" "TAP_SCAN_CLOCK" "of" port_ID colon "signal" "is"
    left_paren clock_record right_paren semicolon ;
TDI_stmt = "attribute" "TAP_SCAN_IN" "of" port_ID colon "signal" "is" "true" semicolon ;
TMS_stmt = "attribute" "TAP_SCAN_MODE" "of" port_ID colon "signal" "is" "true" semicolon ;
TDO_stmt = "attribute" "TAP_SCAN_OUT" "of" port_ID colon "signal" "is" "true" semicolon ;
TRST_stmt = "attribute" "TAP_SCAN_RESET" "of" port_ID colon "signal" "is" "true" semicolon ;
clock_record = real comma halt_state_value ;
halt_state_value = "LOW" | "BOTH" ;

(* B.8.10 *)
compliance_enable_description = "attribute" "COMPLIANCE_PATTERNS" "of"
    component_name colon "entity" "is" compliance_pattern_string semicolon ;
compliance_pattern_string = quote left_paren compliance_port_list right_paren
    left_paren pattern_list right_paren quote ;
compliance_port_list = port_ID { comma port_ID } ;
pattern_list = pattern { comma pattern } ;

(* B.8.11 *)
instruction_register_description =
    instruction_length_stmt
    instruction_opcode_stmt
    instruction_capture_stmt
    [instruction_private_stmt] ;
instruction_length_stmt = "attribute" "INSTRUCTION_LENGTH" "of" component_name
    colon "entity" "is" integer semicolon ;
instruction_opcode_stmt = "attribute" "INSTRUCTION_OPCODE" "of" component_name
    colon "entity" "is" opcode_table_string semicolon ;
instruction_capture_stmt = "attribute" "INSTRUCTION_CAPTURE" "of" component_name
    colon "entity" "is" pattern_list_string semicolon ;
instruction_private_stmt = "attribute" "INSTRUCTION_PRIVATE" "of" component_name
    colon "entity" "is" instruction_list_string semicolon ;
opcode_table_string = quote opcode_description { comma opcode_description } quote ;
opcode_description = instruction_name left_paren opcode_list right_paren ;
opcode_list = opcode { comma opcode } ;
opcode = pattern ;
pattern_list_string = quote opcode_list quote ;
instruction_list_string = quote instruction_list quote ;
instruction_list = instruction_name { comma instruction_name } ;

(* B.8.12 *)
optional_register_description = optional_register_stmt [ optional_register_stmt ] ;
optional_register_stmt = idcode_statement | usercode_statement ;
idcode_statement = "attribute" "IDCODE_REGISTER" "of" component_name
    colon "entity" "is" quote thirty_two_bit_pattern_list quote semicolon ;
usercode_statement = "attribute" "USERCODE_REGISTER" "of" component_name
    colon "entity" "is" quote thirty_two_bit_pattern_list quote semicolon ;
thirty_two_bit_pattern_list = thirty_two_bit_pattern { comma thirty_two_bit_pattern } ;

(* B.8.13 *)
register_access_description = "attribute" "REGISTER_ACCESS" "of"
    component_name colon "entity" "is" register_access_string semicolon ;
register_access_string = quote register_association { comma register_association } quote ;
register_association = register left_paren instruction_capture_list right_paren ;
instruction_capture_list = instruction_capture { comma instruction_capture } ;
instruction_capture = instruction_name [ "CAPTURES" pattern ] ;
register = std_fixed_register | std_var_register | design_specific_register ;
std_fixed_register = "BOUNDARY" | "BYPASS" | "DEVICE_ID" | "TMP_STATUS" ;
std_var_register = std_var_reg_name [ left_bracket reg_length right_bracket ] ;
std_var_reg_name = "ECID" | "INIT_DATA" | "INIT_STATUS" | "RESET_SELECT" ;
design_specific_register = vhdl_identifier [ left_bracket reg_length right_bracket ] ;
reg_length = integer | asterisk ;

(* B.8.14 *)
boundary_scan_register_description = fixed_boundary_stmts | segment_boundary_stmts ;
fixed_boundary_stmts = boundary_length_stmt boundary_register_stmt ;
segment_boundary_stmts = assembled_boundary_length_stmt boundary_register_segments ;
boundary_length_stmt = "attribute" "BOUNDARY_LENGTH" "of"
    component_name colon "entity" "is" register_length semicolon ;
register_length = integer ;
boundary_register_stmt = "attribute" "BOUNDARY_REGISTER" "of"
    component_name colon "entity" "is" cell_table_string semicolon ;
cell_table_string = quote cell_table quote ;
assembled_boundary_length_stmt = "attribute" "ASSEMBLED_BOUNDARY_LENGTH" "of"
    component_name colon "entity" "is"
    left_paren reset_length comma register_length right_paren semicolon ;
reset_length = integer ;
boundary_register_segments = boundary_register_segment { boundary_register_segment } ;
boundary_register_segment = "attribute" "BOUNDARY_SEGMENT" "of"
    component_name colon "entity" "is" boundary_segment_string semicolon ;
boundary_segment_string = quote boundary_segment_list
    { comma boundary_segment_list } quote ;
boundary_segment_list = boundary_segment_name
    left_bracket boundary_segment_length right_bracket
    left_paren cell_table right_paren ;
boundary_segment_name = vhdl_identifier ;
boundary_segment_length = integer ;
cell_table = cell_entry { comma cell_entry } ;
cell_entry = cell_number left_paren cell_info right_paren ;
cell_number = integer ;
cell_info = cell_spec [ comma input_or_disable_spec ] ;
cell_spec = cell_name comma port_ID_or_null comma function comma safe_bit ;
cell_name = vhdl_identifier ;
port_ID_or_null = port_ID | asterisk ;
function = "INPUT" | "OUTPUT2" | "OUTPUT3" | "CONTROL" |
    "CONTROLR" | "INTERNAL" | "CLOCK" | "BIDIR" | "OBSERVE_ONLY" ;
safe_bit = "0" | "1" | "X" ;
input_or_disable_spec = input_spec | disable_spec ;
input_spec = "EXTERN0" | "EXTERN1" | "PULL0" | "PULL1" | "OPEN0" |
    "OPEN1" | "KEEPER" | "OPENX" | "EXPECT1" | "EXPECT0" ;
disable_spec = ccell comma disable_value comma disable_result ;
ccell = integer ;
disable_value = "0" | "1" ;
disable_result = "WEAK0" | "WEAK1" | "PULL0" | "PULL1" | "OPEN0" | "OPEN1" |
    "KEEPER" | "Z" ;

(* B.8.15 *)
runbist_description = "attribute" "RUNBIST_EXECUTION" "of" component_name
    colon "entity" "is" quote runbist_spec quote semicolon ;
runbist_spec = wait_spec comma pin_state comma signature_spec ;
wait_spec = "WAIT_DURATION" left_paren duration_spec right_paren ;
duration_spec = clock_cycles_list | time_and_clocks ;
time_and_clocks = time [ comma clock_cycles_list ] ;
clock_cycles_list = clock_cycles { comma clock_cycles } ;
time = real ;
clock_cycles = port_ID integer ;
pin_state = "OBSERVING" condition "AT_PINS" ;
condition = "HIGHZ" | "BOUNDARY" ;
signature_spec = "EXPECT_DATA" det_pattern ;
det_pattern = bit { bit } ;
bit = "0" | "1" ;

(* B.8.16 *)
intest_description = "attribute" "INTEST_EXECUTION" "of" component_name
    colon "entity" "is" quote intest_spec quote semicolon ;
intest_spec = wait_spec comma pin_state ;

(* B.8.17 *)
system_clock_description = "attribute" "SYSCLOCK_REQUIREMENTS"
    "of" entity_target "is" system_clock_description_string semicolon ;
system_clock_description_string = quote system_clock_requirement
    { comma system_clock_requirement } quote ;
system_clock_requirement = left_paren port_ID comma min_freq comma max_freq
    comma clocked_instructions right_paren ;
min_freq = real ;
max_freq = real ;
clocked_instructions = clocked_instruction { comma clocked_instruction } ;
clocked_instruction = "RUNBIST" | "INTEST" | "INIT_SETUP" |
    "INIT_SETUP_CLAMP" | "INIT_RUN" | "ECIDCODE" | "IC_RESET" | vhdl_identifier ;

(* B.8.18 *)
register_mnemonics_description = "attribute" "REGISTER_MNEMONICS" "of"
    target "is" register_mnemonics_string semicolon ;
target = entity_target | package_target ;
entity_target = component_name colon "entity" ;
package_target = user_package_name colon "package" ;
register_mnemonics_string =
    quote mnemonic_definition { comma mnemonic_definition } quote ;
mnemonic_definition = mnemonic_group_name left_paren mnemonic_list right_paren ;
mnemonic_group_name = vhdl_identifier ;
mnemonic_list = mnemonic_assignment { comma mnemonic_assignment } ;
mnemonic_assignment = mnemonic_identifier
    left_paren pattern_specification right_paren [ information_tag ] ;
pattern_specification = binary_pattern | hex_pattern | decimal_pattern | "others" ;

(* B.8.19 *)
register_fields_description = "attribute" "REGISTER_FIELDS" "of" target "is"
    register_fields_string semicolon ;
register_fields_string = quote register_field_list { comma register_field_list } quote ;
register_field_list = reg_or_seg_name left_bracket reg_or_seg_length right_bracket
    left_paren register_fields right_paren ;
reg_or_seg_name = TDR | segment_name ;
TDR = "BOUNDARY" | "BYPASS" | "DEVICE_ID" | "TMP_STATUS" |
    "ECID" | "INIT_DATA" | "INIT_STATUS" | "RESET_SELECT" |
    design_specific_TDR_name ;
segment_name = vhdl_identifier ;
design_specific_TDR_name = vhdl_identifier ;
reg_or_seg_length = integer ;
register_fields = left_paren register_field_element right_paren
    { comma left_paren register_field_element right_paren } ;
register_field_element = register_field | prefix_statement ;
register_field = extended_field_name field_length is bit_list_and_options ;
extended_field_name = prefix_string field_name ;
prefix_string = { prefix_identifier period } ;
field_name = vhdl_identifier ;
field_length = left_bracket integer right_bracket ;
bit_list_and_options = bit_list { field_options } ;
field_options = type_assignment | value_assignment | reset_assignment ;
bit_list = left_paren [ bit_field { comma bit_field } ] right_paren ;
bit_field = range | integer ;
prefix_statement = "PREFIX" integer prefix_name ;
prefix_name = prefix_identifier | minus_sign ;

(* B.8.20 *)
value_assignment = value_keyword left_paren assignment right_paren ;
value_keyword = "CAPTURES" | "DEFAULT" | "SAFE" | "RESETVAL" | user_extension ;
user_extension = "USER" colon user_keyword ;
user_keyword = vhdl_identifier ;
assignment = assignment_value | asterisk | minus_sign ;
assignment_value = binary_pattern | hex_pattern | decimal_pattern | mnemonic_association ;
mnemonic_association = [ "PACKAGE" package_hierarchy colon ] mnemonic_group_name
    left_paren mnemonic_default right_paren ;
mnemonic_default = mnemonic_identifier | asterisk | minus_sign ;
type_assignment = "NOPI" | "NOPO" | "NOUPD" | "MON" | "PULSE0" | "PULSE1" |
    "DELAYPO" | "NORETAIN" | "SHARED" | user_extension ;
reset_assignment = "PORRESET" | "TRSTRESET" | "TAPRESET" | "CHRESET" |
    "DOMPOR" | "HIERRESET" | local_reset_assignment ;
local_reset_assignment = reset_type left_paren reset_ident right_paren ;
reset_type = "RESETOUT" | "RESETIN" ;
reset_ident = vhdl_identifier ;
domain_assignment = association_type left_paren association_name right_paren ;
association_type = "DOMAIN" | "DOMAIN_EXTERNAL" | "SEGMENT" ;
association_name = vhdl_identifier ;
